#----------------------------------------------------------------------------
# RSuite
# Copyright (c) 2017, WLOG Solutions
#
# Utilities for retrieving project package, master scripts and all further
# dependencies.
#----------------------------------------------------------------------------

#'
#' Detects direct uninstalled project dependencies
#'
#' @param params object of rsuite_project_params class
#'
#' @return object of versions class containing direct project dependencies
#'   which are not installed in prject local environment.
#'
#' @keywords internal
#' @noRd
#'
collect_uninstalled_direct_deps <- function(params) {
  depVers <- collect_prj_direct_deps(params)
  installed <- as.data.frame(utils::installed.packages(params$lib_path), stringsAsFactors = F)[, c("Package", "Version")]
  depVers <- vers.rm_acceptable(depVers, installed)
}

#'
#' Detects all project (project packages and master scripts) direct dependencies.
#'
#' @param params object of rsuite_project_params class
#'
#' @return object of versions class containing all direct project dependencies
#'   together with their version requirements.
#'
#' @keywords internal
#' @noRd
#'
collect_prj_direct_deps <- function(params) {
  pkgVers <- collect_pkgs_direct_deps(params)
  mscVers <- collect_mscs_direct_deps(params)
  prjVers <- vers.union(pkgVers, mscVers)
  return(prjVers)
}

#'
#' Detects all project required support packages.
#'
#' @param params object of rsuite_project_params class
#'
#' @return object of versions class containing all support packages required.
#'   Version requirements for support packages included should be empty.
#'
#' @keywords internal
#' @noRd
#'
collect_prj_support_pkgs <- function(params) {
  prj_packages <- build_project_pkgslist(params$pkgs_path) # from 51_pkg_info.R

  requires_roxygen <- function(pkg_path) {
    has_rgen_mans <- lapply(X = list.files(file.path(pkg_path, "man"), ".+[.]Rd$", full.names = T),
                            FUN = function(rd_file) {
                              if (!all(grepl("^% Generated by roxygen", readLines(rd_file, n = 1)))) {
                                return(FALSE)
                              }
                              return(TRUE)
                            })
    has_rgen_mans <- any(unlist(has_rgen_mans))

    ns_path <- file.path(pkg_path, "NAMESPACE")
    has_rgen_ns <- !file.exists(ns_path) || any(grepl("^# Generated by roxygen", trimws(readLines(ns_path))[1]))

    return(has_rgen_mans || has_rgen_ns)
  }

  sup_pkgs <- unlist(lapply(X = names(prj_packages),
                            FUN = function(pkg_dir) {
                              pkg_path <- file.path(params$pkgs_path, pkg_dir)
                              if (!requires_roxygen(pkg_path)) {
                                return("devtools") # still requires devtools
                              }

                              desc_file <- file.path(pkg_path, "DESCRIPTION")
                              stopifnot(file.exists(desc_file))

                              desc <- read.dcf(desc_file)
                              if (!('RoxygenExtraRoclets' %in% colnames(desc))) {
                                return(c("devtools", "roxygen2"))
                              }

                              roclets <- trimws(strsplit(desc[1, 'RoxygenExtraRoclets'], ", ")[1])

                              unspec_roclets <- roclets[!grepl("^[a-zA-Z]+::", roclets)]
                              assert(length(unspec_roclets) == 0,
                                     "Some extra roclets in %s are underspecified: %s",
                                      pkg_dir, paste(unspec_roclets, collapse = ", "))

                              roc_pkgs <- gsub("^([a-zA-Z]+)::.+$", "\\1", roclets)
                              return(c("devtools", "roxygen2", roc_pkgs))
                            }))
  sup_vers <- vers.build(unique(sup_pkgs))
  return(sup_vers)
}


#'
#' Looks for package DESCRIPTION files and retrieves direct dependencies from them.
#'
#' @param params object of rsuite_project_params class
#' @param prj_pkgs detect dependencies only for specified project packages. If
#'   NULL detect for all. (type: character, default: NULL)
#'
#' @return object of versions class containing all direct dependencies of project
#'   packages together with their version requirements.
#'
#' @keywords internal
#' @noRd
#'
collect_pkgs_direct_deps <- function(params) {
  prj_packages <- build_project_pkgslist(params$pkgs_path) # from 51_pkg_info.R
  pkgs_vers <- do.call("vers.union",
                       lapply(X = names(prj_packages),
                              FUN = function(pkg_dir) {
                                collect_single_pkg_direct_deps(params, pkg_dir, prj_packages[[pkg_dir]])
                              }))

  unfeasibles <- vers.get_unfeasibles(pkgs_vers)
  assert(length(unfeasibles) == 0,
         "Packages with unfeasible requirements detected: %s", paste(unfeasibles$pkg, collapse = ", "))

  # Check R version
  req_r_ver <- vers.get(pkgs_vers, 'R')
  if (nrow(req_r_ver)) {
    cur_r_ver <- sprintf("%s.%s", R.version$major, R.version$minor)
    assert((is.na(req_r_ver$vmin) || req_r_ver$vmin <= cur_r_ver)
           && (is.na(req_r_ver$vmax) || req_r_ver$vmax >= cur_r_ver),
           "R version(%s) does not meet requirements: it must be in range %s .. %s",
           cur_r_ver, req_r_ver$vmin, req_r_ver$vmax)
  }

  pkgs_vers <- vers.rm_base(pkgs_vers)
  return(pkgs_vers)
}


#'
#' Retrieve dependencies with requirements for a single project package
#'
#' @param params object of rsuite_project_params class
#' @param pkg_dir package folder (type: character)
#' @param pkg_name package name as declared in DESCRIPTION (type: character)
#'
#' @return object of versions class containing all direct dependencies of package
#'   together with their version requirements.
#'
#' @keywords internal
#' @noRd
#'
collect_single_pkg_direct_deps <- function(params, pkg_dir, pkg_name) {
  deps <- desc_retrieve_dependencies(params$pkgs_path, pkg_dir) # from 51_pkg_info.R
  vers.from_deps(deps, pkg_name)
}


#'
#' Looks for master scripts and retrieves all direct dependencies from them.
#'
#' @param params object of rsuite_project_params class
#'
#' @return object of versions class containing all direct dependencies of master
#'   scripts. Of cause master scrips cannot enforce version requirements so
#'   versions object does not contain requirements on package versions.
#'
#' @keywords internal
#' @noRd
#'
collect_mscs_direct_deps <- function(params) {
  script_files <- list.files(path = params$script_path, pattern = "*.(r|R|Rmd)$",
                             recursive = TRUE, full.names = TRUE)
  pkgs <- unlist(
    lapply(X = script_files,
           FUN = function(sf) {
             lns <- readLines(sf)
             loads <- lns[grepl("^\\s*(require|library)\\((.+)\\)", lns)]
             loads <- gsub("\\s+", "", loads) # remove extra spaces
             gsub("^(require|library)\\(['\"]?([^,'\"]+)['\"]?(,.+)?\\).*$", "\\2", loads)
           }))
  mscs_vers <- vers.build(unique(pkgs))
  mscs_vers <- vers.rm_base(mscs_vers)
  return(mscs_vers)
}


#'
#' Retrieves all subsequent dependencies for packages described by version
#' object passed.
#'
#' @param vers version object describing packages to retrieve all subsequent
#'    dependencies for.
#' @param repo_info description of repository to search for
#'    dependencies in. Unused if avail_pkgs passed. (object of rsuite_repo_info)
#' @param type type of packages to search. . Unused if avail_pkgs passed.
#' @param all_pkgs matrix same as available.packages return.
#'
#' @return pkgSearchResult object containing packages from vers and all their
#'    subsequent dependencies.
#'
#' @keywords internal
#' @noRd
#'
collect_all_subseq_deps <- function(vers, repo_info, type, all_pkgs = NULL) {
  stopifnot(is.versions(vers))

  if (is.null(all_pkgs)) {
    stopifnot(!missing(repo_info))
    stopifnot(!missing(type))

    contrib_url <- repo_info$get_contrib_url(type)    # from 53_repositories.R
    avail_vers <- vers.collect(contrib_url)
    all_pkgs <- avail_vers$get_avails()
  } else {
    avail_pkgs <- as.data.frame(all_pkgs, stringsAsFactors = F)
    avail_vers <- vers.collect(pkgs = avail_pkgs)
  }

  vers <- vers.rm_base(vers)
  vers_cr <- vers.check_against(vers, avail_vers)

  next_cr <- vers_cr
  while(check_res.has_found(next_cr)) {
    dep_avails <- vers.pick_available_pkgs(check_res.get_found(next_cr))

    dep_vers <- vers.from_deps_in_avails(dep_avails)
    dep_vers <- vers.rm_base(dep_vers)

    next_cr <- vers.check_against(dep_vers, avail_vers)
    vers_cr <- check_res.union(vers_cr, next_cr)
  }

  return(vers_cr)
}
